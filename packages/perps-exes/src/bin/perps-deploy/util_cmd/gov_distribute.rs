use std::{
    collections::{BTreeMap, HashSet},
    path::PathBuf,
};

use anyhow::Result;
use chrono::{DateTime, Utc};
use cosmos::{Address, Coin, Contract, HasAddress, TxBuilder};
use cosmwasm_std::{Decimal256, Timestamp, Uint128, Uint64};
use perps_exes::PerpsNetwork;

#[derive(clap::Parser)]
pub(crate) struct GovDistributeOpt {
    /// File generated by the calculate command
    pub(crate) input: PathBuf,
    /// Governance contract
    #[clap(long)]
    pub(crate) contract: Option<Address>,
    /// How many vesting messages to include in a single tx?
    #[clap(long, default_value_t = 100)]
    pub(crate) vestings_per_tx: u32,
    /// Network
    #[clap(long, env = "COSMOS_NETWORK")]
    pub(crate) network: PerpsNetwork,
}

impl GovDistributeOpt {
    pub(super) async fn go(self, opt: crate::cli::Opt) -> Result<()> {
        let GovDistributeOpt {
            input,
            contract,
            vestings_per_tx,
            network,
        } = self;
        let cosmos = opt.connect(network).await?;
        let contract = match contract {
            Some(contract) => contract,
            None => match cosmos.get_cosmos_builder().chain_id() {
                "osmo-test-5" => {
                    "osmo1cu5extksk3ut9vt0jlelyg0z4k06zh7z0r4vntn4l30xjgf8k65sv5ycwt".parse()?
                }
                "osmosis-1" => {
                    "osmo1r4zttdjswycfcmsm7vxw60kvn6ejw40yld6cspedy5daltml0zxqhpg5xn".parse()?
                }
                chain_id => anyhow::bail!("No known contract for chain ID {chain_id}"),
            },
        };
        let contract = cosmos.make_contract(contract);
        let lazy_wallet = opt.get_lazy_wallet(network)?;
        let wallet = lazy_wallet.get()?;
        let mut vestings = BTreeMap::<Address, Vec<Output>>::new();

        let GlobalInfo {
            config: GovConfig { denom },
        } = contract.query(GovQueryMsg::GlobalInfo {}).await?;

        let mut total = Decimal256::zero();

        for res in csv::Reader::from_path(&input)?.into_deserialize() {
            let output: Output = res?;
            total += output.amount;
            vestings.entry(output.recipient).or_default().push(output);
        }

        println!("Total distribution: {total}");

        let mut tx_builder = TxBuilder::default();
        let mut message_count = 0;

        for (recipient, outputs) in vestings {
            let existing = get_existing_vestings(&contract, recipient).await?;

            for Output {
                recipient,
                amount,
                vesting_date,
                clawback,
                can_vote,
                can_receive_rewards,
                title,
            } in outputs
            {
                let uamount = (amount * Decimal256::from_ratio(1_000_000u32, 1u8)).to_uint_floor();
                if existing.contains(&title) {
                    println!("{recipient}: vesting already exists, skipping: {title}",);
                    continue;
                }

                println!("{recipient}: creating new vesting: {title}");
                let now = Utc::now();
                anyhow::ensure!(
                    now < vesting_date,
                    "Vesting date of {vesting_date} is in the past, current time: {now}"
                );

                let duration = vesting_date - now;

                message_count += 1;
                tx_builder.add_execute_message(
                    &contract,
                    wallet,
                    vec![Coin {
                        denom: denom.clone(),
                        amount: uamount.to_string(),
                    }],
                    GovExecuteMsg::BeginVesting {
                        recipient: recipient.get_address_string(),
                        duration: Interval::Seconds(u64::try_from(duration.num_seconds())?.into()),
                        title,
                        clawback_addr: clawback,
                        can_vote,
                        can_receive_rewards,
                    },
                )?;

                if message_count >= vestings_per_tx {
                    message_count = 0;
                    let tx_builder = std::mem::take(&mut tx_builder);
                    let res = tx_builder.sign_and_broadcast(&cosmos, wallet).await?;
                    println!("Transaction hash: {}", res.txhash);
                }
            }
        }

        if message_count > 0 {
            let res = tx_builder.sign_and_broadcast(&cosmos, wallet).await?;
            println!("Transaction hash: {}", res.txhash);
        }

        Ok(())
    }
}

/// Returns a set of all the titles
async fn get_existing_vestings(contract: &Contract, wallet: Address) -> Result<HashSet<String>> {
    let mut res = HashSet::new();
    let mut start_after = None;

    loop {
        let records: Vec<TimeAction> = contract
            .query(GovQueryMsg::PendingActions {
                address: wallet.get_address_string(),
                start_after: start_after.take(),
                limit: 30,
                ascending: true,
            })
            .await?;

        match records.last() {
            Some(last) => start_after = Some(last.id),
            None => break Ok(res),
        }

        for TimeAction {
            id: _,
            ty,
            start: _,
            end: _,
        } in records
        {
            match ty {
                TimeActionType::Timelock {} => (),
                TimeActionType::Unstake {} => (),
                TimeActionType::Vest {
                    amount: _,
                    clawback_addr: _,
                    title,
                    options: _,
                } => {
                    res.insert(title);
                }
            }
        }
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
struct Output {
    recipient: Address,
    amount: Decimal256,
    vesting_date: DateTime<Utc>,
    clawback: Option<String>,
    can_vote: bool,
    can_receive_rewards: bool,
    title: String,
}

#[derive(Clone, PartialEq, serde::Serialize, serde::Deserialize, Debug)]
struct TimeAction {
    id: Uint64,
    ty: TimeActionType,
    start: Timestamp,
    end: Timestamp,
}

#[derive(Clone, PartialEq, serde::Serialize, serde::Deserialize, Debug)]
#[serde(rename_all = "snake_case")]
enum TimeActionType {
    Timelock {},
    Unstake {},
    Vest {
        amount: Uint128,
        clawback_addr: Option<Address>,
        title: String,
        options: VestingOptions,
    },
}

#[derive(Clone, Copy, PartialEq, serde::Serialize, serde::Deserialize, Debug)]
#[serde(rename_all = "snake_case")]
enum VestingOptions {
    None,
    Voting,
    Rewards,
    VotingAndRewards,
}

#[derive(Clone, serde::Serialize, Debug)]
#[serde(rename_all = "snake_case")]
enum GovExecuteMsg {
    BeginVesting {
        recipient: String,
        duration: Interval,
        title: String,
        clawback_addr: Option<String>,
        can_vote: bool,
        can_receive_rewards: bool,
    },
}

#[derive(Clone, Copy, serde::Serialize, Debug)]
#[serde(rename_all = "snake_case")]
enum Interval {
    Seconds(Uint64),
}
#[derive(serde::Deserialize)]
struct GlobalInfo {
    config: GovConfig,
}
#[derive(serde::Deserialize)]
struct GovConfig {
    denom: String,
}
#[derive(serde::Serialize)]
#[serde(rename_all = "snake_case")]
enum GovQueryMsg {
    GlobalInfo {},
    PendingActions {
        address: String,
        start_after: Option<Uint64>,
        limit: i32,
        ascending: bool,
    },
}
